<!DOCTYPE html>
<html>
  <head>
    <title>YZG</title>
  </head>
  <body>
    <!-- PixiJS ve TensorFlowJS kütüphaneleri eklendi -->
    <script src="https://pixijs.download/release/pixi.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs/dist/tf.min.js"></script>
    <script type="module">
      /*
        TODO:
            there should be separate velocities for cars' internal speed and external forces, currently a crash from side would cause the car to turn
            there should be an array per sprite to determine the bounding rectangle (eg. [0.2,0.8,0.3,0.8] should make the collision detector use 120x40 of an 200x80 image, the elements are ordered as: startX, endX, startY, endY)
              collision detection
                collision resolution
            road sprites, road signs, different cars
        */
      // Oyun ekranı boyutları
      const WIDTH = 800;
      const HEIGHT = 600;
      const app = new PIXI.Application();
      const { BitmapText } = PIXI;
      await app.init({ width: WIDTH, height: HEIGHT });
      await PIXI.Assets.load("../assets/temp_car.png");

      let sleep = (ms) => new Promise((res) => setTimeout(res, ms));
      let tempSprite = PIXI.Sprite.from("../assets/temp_car.png");
      document.body.appendChild(app.canvas);
      let cars = [];

      // Araç özellikleri
      const CAR_WIDTH = 64;
      const DRAG = 4.4; // increases drag when increased, was meant to decrease
      const TURN_DRAG = 0.8; // 0-1.0
      const MOVE_MULTIPLIER = 600; // acceleration, should be increased when drag is increased
      const MIN_STEERING_SPEED = 10
      let toRadian = (x) => (x / 180) * Math.PI;
      let getMagnitude = (...arr) =>
        Math.sqrt(arr.reduce((x, y) => x + y ** 2, 0));
      let toVector = x=>[Math.cos(toRadian(x)),Math.sin(toRadian(x))]
      let dotProduct = (x,y)=>{
        let product = 0
        for(let i = 0;i<x.length;i++)product+=x[i]*y[i]
        return product
      }
      let toDegree = (x) => (x / Math.PI) * 180;
      class Car {
        accX = 0;
        accY = 0;
        velX = 0;
        velY = 0;
        posX = 0;
        posY = 0;
        directionOffset = 90; // direction of the sprite is used, should normally be dynamic
        _direction = 0;
        lastDirection = 0;
        get direction() {
          return this._direction + this.directionOffset; //in order to use rotated sprites
        }
        set direction(val) {
          return (this._direction = val - this.directionOffset);
        }
        get position(){
          return [this.posX,this.posY]
        }
        setPosition(x,y){
          this.posX=x
          this.posY=y
        }
        set position(val){
          this.setPosition(val[0],val[1])
        }
        inScene = false;
        _sprite;
        ratio;
        get sprite() {
          return this._sprite;
        }
        set sprite(currSprite) {
          if (this._sprite) app.stage.removeChild(this._sprite);
          this._sprite = currSprite;
          if (!this.inScene) {
            this.inScene = true;
          }
          let wh = tempSprite.getSize();
          this.ratio = wh.height / wh.width;
          currSprite.setSize(CAR_WIDTH, CAR_WIDTH * this.ratio);
          currSprite.anchor.set(0.3, 0.5);
          app.stage.addChild(currSprite);
        }

        // Hız büyüklüğünü hesaplayan fonksiyon
        absoluteVel() {
          return getMagnitude(this.velX, this.velY);
        }
        // İvme büyüklüğünü hesaplayan fonksiyon
        absoluteAcc() {
          return getMagnitude(this.accX,this.accY)
        }
        tick(dt) {
          this.velX += this.accX * dt;
          this.velY += this.accY * dt;
          let nextVelY = this.velY * DRAG * dt;
          let nextVelX = this.velX * DRAG * dt;
          this.accX = (nextVelX - this.velX) * DRAG;
          this.accY = (nextVelY - this.velY) * DRAG;
          let diffX = this.velX * dt;
          let diffY = this.velY * dt;
          let absVel = this.absoluteVel();
          let absAcc = this.absoluteAcc();
          let nextAngle;
          if (absVel == 0) {
            nextAngle = this.lastDirection;
          } else nextAngle = toDegree(Math.atan2(this.velY, this.velX));
          this.posX += diffX;
          this.posY += diffY;
          this.sprite.x = this.posX;
          this.sprite.y = this.posY;
          this.sprite.angle = nextAngle;
          if (this._direction != this.sprite.angle) {
            nextAngle = this._direction;
            this.accX *= TURN_DRAG;
            this.accY *= TURN_DRAG;
            this.sprite.angle = nextAngle;
          } else {
            this._direction = nextAngle;
          }
          if (absVel < 0.01) {
            this.lastDirection = this._direction;
            this.velX = 0;
            this.velY = 0;
          }
          if (absAcc < 0.001) {
            this.accX = 0;
            this.accY = 0;
          }
        }
        // İleri hareket fonksiyonu
        moveForward(scale=1) { // 0-1.0, will necessary to control acceleration
          let degree = this._direction;
          let radian = (Math.PI * degree) / 180;
          this.accX += Math.cos(radian) * MOVE_MULTIPLIER*scale;
          this.accY += Math.sin(radian) * MOVE_MULTIPLIER*scale;
        }
        // Geri hareket fonksiyonu
        moveBackwards(scale=1){
          let degree = this._direction;
          let radian = (Math.PI * degree) / 180;
          this.accX += (-Math.cos(radian) * MOVE_MULTIPLIER) / 2*scale;
          this.accY += (-Math.sin(radian) * MOVE_MULTIPLIER) / 2*scale;
          this.allowChange = true;
        }
        isGoingBackwards(){
            return dotProduct([this.velX,this.velY],toVector(this.sprite.angle))<-0.2
        }
        steerLeft(){
            if(this.absoluteVel()<MIN_STEERING_SPEED)return
            if(this.isGoingBackwards())return this.direction+=0.5
            this.direction--
        }
        steerRight(){
            if(this.absoluteVel()<MIN_STEERING_SPEED)return
            if(this.isGoingBackwards())return this.direction-=0.5
            this.direction++
        }
        constructor() {
          cars.push(this);
        }
      }

      // Ana araç sınıfı
      class MainCar extends Car {
        constructor() {
          super();
          this.sprite = tempSprite;
        }
      }
      let mainCar = new MainCar();
      mainCar.setPosition(50,50)
      const ticker = PIXI.Ticker.system;
      //testing section, will be deleted
      let frameTimes = [];
      let isDown = {};

      // Klavye olayları
      window.addEventListener("keydown", (event) => {
        const isLetter = /^[a-zA-Z]$/.test(event.key);
        if (isLetter && !event.repeat) {
          isDown[event.key.toUpperCase()] = 1;
        }
      });
      window.addEventListener("keyup", (event) => {
        delete isDown[event.key.toUpperCase()];
      });
      let frameText = "0";
      let counter = 0;
      ticker.add((dt) => {
        if (counter++ % 1 == 0)
          cars.forEach((car) => {
            if (isDown["W"] || isDown["A"] || isDown["D"] || isDown["S"]) {
              if (isDown["W"]) {
                car.moveForward();
              }
              if (isDown["S"]) {
                car.moveBackwards();
              }
              if (isDown["A"]) {
                car.steerLeft()
              }
              if (isDown["D"]) {
                car.steerRight()
              }
            }
            car.tick(dt.deltaMS / 1000);
          });
        frameTimes.push(Date.now());
      });

      // FPS Sayacı
      const bitmapFontText = new BitmapText({
        text: frameText,
        style: {
          fontFamily: "Desyrel",
          fontSize: 20,
          align: "left",
        },
      });
      bitmapFontText.x = 300;
      bitmapFontText.y = 0;
      app.stage.addChild(bitmapFontText);
      // FPS Hesaplama
      setInterval(() => {
        let now = Date.now();
        frameTimes = frameTimes.filter((e) => now - e < 1000);
        frameText = frameTimes.length.toString();
        bitmapFontText.text = frameText;
      }, 1000);
    </script>
  </body>
</html>
