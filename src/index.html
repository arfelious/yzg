<!DOCTYPE html>
<html>
  <head>
    <title>YZG</title>
  </head>
  <body>
    <!-- PixiJS ve TensorFlowJS kütüphaneleri eklendi -->
    <script src="../modules/pixi.js"></script>
    <script src="../modules/tf.min.js"></script>
    <script type="module">
      /*
        TODO:
            araçların ayrı sprite'ları olmalı, sprite atamak yerine kullanılacak resmi belirtmeliyiz
            hızı, ivmeyi ve sürtünmeyi belirleyen sabit değerler yola ve araca bağlı olmalı, şimdilik hangi tür yol olduğunu söyleyen yer tutucu fonksiyon yazabiliriz
              isUsingBrake kullanılırken TURN_DRAG değiştirilmeli
            collidersEquals fonksiyonu yazılmalı 
              prev array'indeki her elemanın next'te de bulunmasına bakması yeterli olur ama optimize edilebilir
            araçların iç ve dış hız değerleri farklı olmalı. araçların yönü hızına göre belirlendiği için bir araç çarparsa araç aniden yön değiştirir, önlemek içi ayrı hız değerleri kullanılıp hesaplamalarda ikisini beraber kullanacak bi hız değeri kullanılır. direction ve _direction'da olduğu gibi getter setter kullanılmalı
            yol sprite'ları, trafik işaretleri, farklı araçlar eklenmeli
            fps'ten bağımsız hareket sistemi, açıya bağlı yön sisteminde de aynısı uygulandığında düzenlenerek eklenecek
            collision detection
              collision resolution
        MAYBE:
          visualize buttons as they are being pressed, might be necessary when RL model is used
        */
      // Oyun ekranı boyutları
      const WIDTH = 800;
      const HEIGHT = 600;
      const app = new PIXI.Application();
      const { BitmapText } = PIXI;
      await app.init({ width: WIDTH, height: HEIGHT, antialias: true,autoDensity: true});
      await PIXI.Assets.load("../assets/temp_car.png");

      let sleep = (ms) => new Promise((res) => setTimeout(res, ms));
      let tempSprite = PIXI.Sprite.from("../assets/temp_car.png");
      let randSprite = PIXI.Sprite.from("../assets/temp_car.png");
      document.body.appendChild(app.canvas);
      let entities = []
      let cars = [];
      // Araç özellikleri
      const CAR_WIDTH = 64;
      const DRAG = 4.4; // increases drag when increased, was meant to decrease
      const TURN_DRAG = 0.8; // 0-1.0
      const MOVE_MULTIPLIER = 700; // acceleration, should be increased when drag is increased
      const STEERING_MULTIPLIER = 0.75
      const MIN_ALIGNMENT = 0.7
      let toRadian = (x) => (x / 180) * Math.PI;
      let getMagnitude = Math.hypot
      let toVector = x=>[Math.cos(toRadian(x)),Math.sin(toRadian(x))]
      let toUnitVector = x=>{
        let length = getMagnitude(x[0],x[1])
        return [x[0]/length,x[1]/length]
      }
      let dotProduct = (x,y)=>{
        let product = 0
        for(let i = 0;i<x.length;i++)product+=x[i]*y[i]
        return product
      }
      let crossProduct = (P, Q, R) => {
        return (Q[0]-P[0])*(R[1]-P[1])-(Q[1]-P[1])*(R[0]-P[0]);
      };
      let getOrientation = (P, Q, R) => {
        const val = crossProduct(P, Q, R);
        if(val==0)return 0;
        return val>0?1:2
      };
      let isOnLineSegment = (P, Q, R) => {
        return (Q[0] < Math.max(P[0], R[0]) && Q[0] > Math.min(P[0], R[0]) &&
                Q[1] < Math.max(P[1], R[1]) && Q[1] > Math.min(P[1], R[1]));
      }
      let checkIntersects = (A, B, C, D) =>{
        const o1 = getOrientation(A,B,C);
        const o2 = getOrientation(A,B,D);
        const o3 = getOrientation(C,D,A);
        const o4 = getOrientation(C,D,B);
        if(o1 != o2 && o3 != o4) return true;
        if(o1==0&&isOnLineSegment(A,C,B)) return true;
        if(o2==0&&isOnLineSegment(A,D,B)) return true;
        if(o3==0&&isOnLineSegment(C,A,D)) return true;
        if(o4==0&&isOnLineSegment(C,B,D)) return true;
        return false;
      }
      let toDegree = (x) => (x / Math.PI) * 180;
      let getBounds = sprite=>{
        let extracted = app.renderer.extract.pixels(sprite)
        let xMin=255,yMin=255,xMax=0,yMax=0
        let pixels= extracted.pixels
        let {width,height} = extracted
        let pixelsLength = pixels.length
        for(let i = 0;i<pixelsLength;i+=4){
          let index = i/4
          let x = index%width
          let y = Math.floor(index/width)
          let a = pixels[i+3]
          if(a>200){
            if(x<xMin)xMin=x
            if(x>xMax)xMax=x
            if(y<yMin)yMin=y
            if(y>yMax)yMax=y
          }
        }
        let retVal = [[xMin,yMin],[xMin,yMax],[xMax,yMin],[xMax,yMax]]
        return retVal
      }
      let collidersEquals = (prev,next)=>{
        //TODO
        return false
      }
      class Car {
        accX = 0;
        accY = 0;
        velX = 0;
        velY = 0;
        posX = 0;
        posY = 0;
        directionOffset = 90; // direction of the sprite is used, should normally be dynamic
        _direction = 0;
        lastDirection = 0;
        isUsingBrake=false
        bounds;
        scale;
        anchorX=0.3
        anchorY=0.5
        graphics;
        boundingRect
        lastColliders;
        _fillColor=0xff9900
        shouldDraw=false
        drawCollision=true
        // Toggles debug graphics that outlines the sprite, it should change color when the entity collides
        createGraphics=true
        collisionBounds
        drawGraphics(clearRect){
          if(!this.createGraphics)return
          if(clearRect)this.graphics.clear()
          this.graphics.rect(...this.boundingRect)
          this.graphics.fill(this.fillColor)
          if(this.drawCollision){
            let lines = this.getLines()
            this.lines.forEach((e,i)=>{
              let line = lines[i]
              e.clear()
              e.moveTo(line[0][0],line[0][1])
                .lineTo(line[1][0],line[1][1]).stroke();
            })
          }
        }
        init(sprite){
          this.bounds=getBounds(sprite)
          let wh = sprite.getSize();
          this.ratio = wh.height / wh.width;
          this.scale=CAR_WIDTH/wh.width
          sprite.setSize(CAR_WIDTH, CAR_WIDTH * this.ratio);
          sprite.anchor.set(this.anchorX,this.anchorY);
          this._sprite = sprite;
          this.scaledBounds=[this.bounds[0][0],this.bounds[0][1],this.bounds[3][0]-this.bounds[0][0],this.bounds[3][1]-this.bounds[0][1]].map(e=>e*this.scale)
          if(this.createGraphics){
            this.graphics = new PIXI.Graphics();   
            this.lines=Array(4).fill().map(()=>new PIXI.Graphics())
            this.lines.forEach(e=>{
              e.setStrokeStyle(1, 0x099ff)
              app.stage.addChild(e)
              })   
            this.collisionGraphics= new PIXI.Graphics()
            app.stage.addChild(this.graphics);
            app.stage.addChild(this.collisionGraphics);
            this.boundingRect=this.scaledBounds
              .map((e,i)=>e-(i==0?this.sprite.width*this.anchorX:i==1?this.sprite.height*this.anchorY:0))
            this.drawGraphics()
          }
        }
        a=0
        getLines(){
          /*
            A----B
            |    |
            D----C
          */
          let width = this.scaledBounds[2]
          let height = this.scaledBounds[3]
          let offsetAngleRad = Math.atan2(this.scaledBounds[0],this.scaledBounds[1])
          let startAngleRad = toRadian(this._direction)
          let xMultiplier = Math.cos(startAngleRad)
          let yMultiplier = Math.sin(startAngleRad)
          let anchorX = CAR_WIDTH*this.anchorX-this.scaledBounds[0]
          let anchorY = CAR_WIDTH*this.anchorY*this.ratio-this.scaledBounds[1]
          let anchorOffsetX=anchorX*xMultiplier-anchorY*yMultiplier
          let anchorOffsetY = anchorX*yMultiplier+anchorY*xMultiplier
          let xOffset = this.posX-anchorOffsetX
          let yOffset = this.posY-anchorOffsetY
          //¯\_(ツ)_/¯
          let A = [xOffset,yOffset]
          let B = [A[0]+width*xMultiplier,A[1]+width*yMultiplier]
          let C = [B[0]+height*Math.cos(toRadian(90)+startAngleRad),B[1]+height*Math.sin(toRadian(90)+startAngleRad)]
          let D = [C[0]+width*Math.cos(toRadian(180)+startAngleRad),C[1]+width*Math.sin(toRadian(180)+startAngleRad)]
          let AB = [A,B]
          let BC = [B,C]
          let CD = [C,D]
          let DA = [D,A]
          this.shouldDraw=true
          return [AB,BC,CD,DA]
        }
        setGraphics(){
          if(this.createGraphics){
            this.graphics.x=this.posX
            this.graphics.y=this.posY
            this.graphics.angle=this.sprite.angle
          }
          if(this.shouldDraw){
            this.drawGraphics(true)
          }
        }
        set fillColor(value){
          if(this.graphics){
            this.graphics.fill(value)
            this.shouldDraw=true
          }
          return this._fillColor=value
        }
        get fillColor(){
          return this._fillColor
        }
        get direction() {
          return this._direction + this.directionOffset; //in order to use rotated sprites
        }
        set direction(val) {
          return (this._direction = val - this.directionOffset);
        }
        setPosition(x,y){
          this.posX=x
          this.posY=y
        }
        get position(){
          return [this.posX,this.posY]
        }
        set position(val){
          this.setPosition(val[0],val[1])
        }
        inScene = false;
        _sprite;
        ratio;
        get sprite() {
          return this._sprite;
        }
        set sprite(currSprite) {
          if (this._sprite) app.stage.removeChild(this._sprite);
          if (!this.inScene) {
            this.inScene = true;
          }
          this.init(currSprite)
          app.stage.addChild(currSprite);
        }

        // Hız büyüklüğünü hesaplayan fonksiyon
        absoluteVel() {
          return getMagnitude(this.velX, this.velY);
        }
        // İvme büyüklüğünü hesaplayan fonksiyon
        absoluteAcc() {
          return getMagnitude(this.accX,this.accY)
        }
        getColliders(){
          let currLines = this.getLines()
          return entities.filter(e=>{
            if(e==this)return false
            let entityLines = e.getLines()
            return currLines.find(l1=>{
              let retVal = entityLines.find(l2=>checkIntersects(...l1,...l2))
              return retVal
            })
          })
        }
        tick(dt) {
          this.velX += this.accX * dt;
          this.velY += this.accY * dt;
          let nextVelY = this.velY * DRAG * dt;
          let nextVelX = this.velX * DRAG * dt;
          this.accX = (nextVelX - this.velX) * DRAG;
          this.accY = (nextVelY - this.velY) * DRAG;
          let diffX = this.velX * dt;
          let diffY = this.velY * dt;
          let absVel = this.absoluteVel();
          let absAcc = this.absoluteAcc();
          let nextAngle;
          if (absVel == 0) {
            nextAngle = this.lastDirection;
          } else nextAngle = toDegree(Math.atan2(this.velY, this.velX));
          let nextColliders = this.getColliders()
          if(!collidersEquals(this.lastColliders,nextColliders)||1){
            this.fillColor=nextColliders.length==0?0xff9900:0xff0000
          }
          this.lastColliders=nextColliders
          this.posX += diffX;
          this.posY += diffY;
          this.sprite.x = this.posX;
          this.sprite.y = this.posY;
          this.sprite.angle = nextAngle;
          if (this._direction != this.sprite.angle) {
            nextAngle = this._direction;
            this.accX *= TURN_DRAG;
            this.accY *= TURN_DRAG;
            this.sprite.angle = nextAngle;
          } else {
            this._direction = nextAngle;
          }
          if (absVel < 0.01) {
            this.lastDirection = this._direction;
            this.velX = 0;
            this.velY = 0;
          }
          if (absAcc < 0.001) {
            this.accX = 0;
            this.accY = 0;
          }
          this.isUsingBrake=false
        }
        // İleri hareket fonksiyonu
        moveForward(scale=1) { // 0-1.0, will necessary to control acceleration
          let degree = this._direction;
          let radian = (Math.PI * degree) / 180;
          this.accX += Math.cos(radian) * MOVE_MULTIPLIER*scale;
          this.accY += Math.sin(radian) * MOVE_MULTIPLIER*scale;
        }
        // Geri hareket fonksiyonu
        moveBackward(scale=1){
          let degree = this._direction;
          let radian = (Math.PI * degree) / 180;
          this.accX += (-Math.cos(radian) * MOVE_MULTIPLIER) / 2*scale;
          this.accY += (-Math.sin(radian) * MOVE_MULTIPLIER) / 2*scale;
        }
        getAlignment(){
          return dotProduct(toUnitVector([this.velX,this.velY]),toVector(this._direction))
        }
        isGoingBackwards(alignment=getAlignment()){
            return alignment<0
        }
        steer(angle) {
          let currentMultiplier = STEERING_MULTIPLIER;
          let alignment = this.getAlignment()
          let isGoingBackwards = this.isGoingBackwards(alignment);
          if(Math.abs(alignment)<MIN_ALIGNMENT)return
          if (this.isUsingBrake) {
              currentMultiplier *= 0.5;
          } 
          if (isGoingBackwards) {
              currentMultiplier*=-0.7 // - yön için, 0.7 daha az dönmesi için
          } 
          this.direction += angle * currentMultiplier;
        }
        steerLeft(){
            this.steer(-1)
        }
        steerRight(){
            this.steer(1)
        }
        brake(dt){
          this.accX*=0.9**(1-dt)
          this.accY*=0.9**(1-dt)
          this.velX*=0.9**(1-dt)
          this.velY*=0.9**(1-dt)
          this.isUsingBrake=true
        }
        destroy(){
          cars.splice(cars.indexOf(this),1)
        }
        constructor() {
          entities.push(this)
          cars.push(this);
        }
      }

      // Ana araç sınıfı
      class MainCar extends Car {
        constructor() {
          super();
          this.createGraphics=true
          this.sprite = tempSprite;
        }
      }
      let mainCar = new MainCar();
      window.mainCar=mainCar
      mainCar.setPosition(80,50)
      let randCar = new Car()
      randCar.sprite=randSprite
      randCar.setPosition(200,50)
      const ticker = PIXI.Ticker.system;
      //testing section, will be deleted
      let frameTimes = [];
      let isDown = {};

      // Klavye olayları
      window.addEventListener("keydown", (event) => {
        const isLetter = /^[a-zA-Z ]$/.test(event.key);
        if (isLetter && !event.repeat) {
          isDown[event.key.toUpperCase()] = 1;
        }
        if(event.key==" "){
          event.preventDefault()
        }
      });
      window.addEventListener("keyup", (event) => {
        delete isDown[event.key.toUpperCase()];
      });
      let frameText = "0";
      let counter = 0;
      ticker.add((dt) => {
        if(counter++%1==0){
          let deltaTime = dt.deltaMS/1000
          if (isDown["W"] || isDown["A"] || isDown["D"] || isDown["S"]||isDown[" "]) {
              if (isDown[" "]) {
                mainCar.brake(deltaTime)
              }
              if (isDown["W"]) {
                mainCar.moveForward();
              }
              if (isDown["S"]) {
                mainCar.moveBackward();
              }
              if (isDown["A"]) {
                mainCar.steerLeft()
              }
              if (isDown["D"]) {
                mainCar.steerRight()
              }
            }
          cars.forEach((car) => {
            car.tick(deltaTime);
          });
          entities.forEach(e=>e.setGraphics())
          frameTimes.push(Date.now());
        }
      });


      // FPS Sayacı
      let fpsFontSize = 20
      const bitmapFontText = new BitmapText({
        text: frameText,
        style: {
          fontFamily: "Desyrel",
          fontSize: fpsFontSize,
          align: "left",
        },
      });
      bitmapFontText.x = (WIDTH-fpsFontSize)/2
      bitmapFontText.y = 0;
      app.stage.addChild(bitmapFontText);
      // FPS Hesaplama
      setInterval(() => {
        let now = Date.now();
        frameTimes = frameTimes.filter((e) => now - e < 1000);
        frameText = frameTimes.length.toString();
        bitmapFontText.text = frameText;
        bitmapFontText.x=(WIDTH-fpsFontSize*frameText.length)/2
      }, 1000);
    </script>
  </body>
</html>
